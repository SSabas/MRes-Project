/* 16.8.98 Test program for v9 (final) sobol generator. 
Prints Sobol sequence. */


//////////////////////////////////////////////////////////////////////////////
//                      N-DIMENSIONAL SOBOL GENERATOR                       //
//////////////////////////////////////////////////////////////////////////////

/* Courtesy of Benedict Tanyi, FECIT.  Who actually wrote it, I haven't a 
   clue!     -rjs */


//*******************************************************************//
//
/*     SOBOL GENERATOR SUBROUTINE   */
//
/* 27.8.98 This subroutine generates Sobol sequences. It is 
thread-safe. The Sobol sequence can have dimension upto MAXDIM.

********************************************************************

USAGE:

(1)Global initialisation:
sob_initialise();
This calculates what are called direction numbers, used in the 
generator. It should be called only once.

(2)Local initialisation:
sob_set(&counter, dimension, start, blocksize);
-counter contains internal variables for this routine.
-dimension is the dimension of the quasi-random sequence.
-start is the starting index.
-blocksize is the number of l.d. numbers generated by one call of sobseq().

This is done in every function/thread that needs its own Sobol 
generator. Here we are setting up the struct sob_data *counter, 
which is not handled directly by the user. int dimension is the 
dimension of the quasi-random vector to be generated. 
long start is the sequence index which we wish to start generating 
at (i.e. we skip the first 'start' no. of points). 
long blocksize is the no. of quasi-random vectors we generate per 
function call. 
Within a given function/thread, sob_set may be recalled thus 
resetting the Sobol generator. 

(3)Generator function:
void sobseq(&counter, x);
Ths calculates blocksize no. of quasi-random vectors of the given
dimension,to the location double *x. 
This must be at least of size (dimension*blocksize+1)*sizeof(double). 
The array index for x starts at 1 (not 0).

********************************************************************

OVERVIEW:

To generate a d-dimensional Sobol number one must choose a 
primitive polynomial (coeffs. are 0 or 1, and this is 
unfactorizable) for each dimension. A list of primitive polynomials
is codified in the array unsigned long ip[] (see Numerical recipes
in C).
     Now, each primitive polynomial forms a recurrence relation to 
generate subsequent direction nos. For a polynomial of order n, we
must give the first n direction nos. for use in the recurrence
relation initially. There is no obvious way to choose these and I
have found my method works well. These initial direction numbers are
generated in the function initial(). Finally, subsequent direction
nos. are calculated and stored in the global array unsigned long
sobol_iv[]. This is the function of sob_initialise().
     To ensure generator is thread-safe any variables that were 
previously static have been put into the struct sob_data, which is
stored in the calling program/thread. 
     It is the job of sob_set() to (locally) initialise this struct,
together with a slight generalistion of the Sobol generator. 
The Antonov-Saleev method is by far the most efficient form to use.
It is however recursive, which complicates splitting up a simulation
into groups (of threads), as each group would skip all the prior
groups ranges of Sobol nos. Fortunately, a variation of Sobol's 
original method is used to skip over the necessary no. of points.
     Finally, the function sobseq() uses the recursive 
Anotonov-Saleev method to generate the Sobol nos.

*******************************************************************/

#define IN_SOBOL_GENERATOR

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "sobol.h"
                 
unsigned long mdeg(int);
unsigned long initial(unsigned long deg, int dir_no);

int sobol_init = 0; /* 0 = un-initialised, 1 = initialised */
unsigned long sobol_iv[MAXDIM*MAXBIT+1]; 


/*sob_initialise() generates the direction numbers and stores these
in the global array unsigned long sobol_iv[MAXDIM*MAXBIT+1]; */

void sob_initialise()
{
    int j,k,l;
    unsigned long i,ipp, m;
    unsigned long *iu[MAXBIT+1];
    unsigned long ip[MAXDIM+1]={ 0, 0, 1, 1,2, 1,4,   
                    /*1st 0 discarded. prim poly's for degs 1 to 4*/
      2,4,7,11,13,14,      /*prim poly's order 5*/
      1,13,16,19,22,25,    /*order 6*/
      1,4,7,8,14,19,21,28,31,32,37,41,42,50,55,56,59,62, /*order 7*/
     14,21,22,38,47,49,50,52,56,67,70,84,97,103,115,122, /*order 8*/
    8,13,16,22,25,44,47,52,55,59,62,67,74,81,82,87,91,94,103,104,
    109,122,124,137,138,143,145,152,157,167,173,176,181,182,185,
    191,194,199,218,220,227,229,230,234,236,241,244,253, /*order 9*/
  4,13,19,22,50,55,64,69,98,107,115,121,127,134,140,145,152,158,
  161,171,181,194,199,203,208,227,242,251,253,265,266,274,283,289,
  295,301,316,319,324,346,352,361,367,382,395,398,400,412,419,422,
  426,428,433,446,454,457,472,493,505,508 /*order 10*/};


    if(sobol_init == 0) {
        sobol_init = 1;
        for (j=1,k=0;j<=MAXBIT;j++,k+=MAXDIM) iu[j] = &sobol_iv[k];
        for (k=1;k<=MAXDIM;k++) {
            m = mdeg(k);
            for (j=1;j<=m;j++) 
	      iu[j][k] = initial(m, j) << (MAXBIT-j); /*changed*/
            for (j=m+1;j<=MAXBIT;j++) {
                ipp=ip[k];
                i=iu[j-m][k];
                i ^= (i >> m);
                for (l=m-1;l>=1;l--) {
                    if (ipp & 1) i ^= iu[j-l][k];
                    ipp >>= 1;
                }
                iu[j][k]=i;
            }
        }

    }

}


/*sob_set() sets up the struct sob_data counter, and if long start
is greater than 1, it uses a variation of Sobol's original method
to skip over the required no. of points so that we can still use
the Antonov-Saleev method in sobseq()*/ 

void sob_set(struct SobolData *counter, int dimension, long start, 
	     long blocksize)
{
  int j,k,l;
  unsigned long i, im;

  /*Error checks*/
  if(dimension < 1) {
    fprintf(stderr, "sob_set(): dimension > 0\n");
    exit(1);
  }
  if(start < 1) {
    fprintf(stderr, "sob_set(): start > 0\n");
    exit(1);
  }
  if(blocksize < 1) {
    fprintf(stderr, "sob_set(): blocksize > 0\n");
    exit(1);
  }

  /*Set struct sob_data*/
  counter->dimension = dimension;
  counter->start = start;
  counter->blocksize = blocksize;
  counter->fac=1.0/(1L << MAXBIT);

    /*Also allows sobseq to be re-initialised*/
    if (start == 1)  { 

      /* 0 starts the Antonov-Saleev recurrence relation*/
      for(j=0; j<=MAXDIM; j++) counter->ix[j] = 0; 
      counter->in = 0;

    } else if(start > 1) {

	/*Using Gray code method*/
        /* for the Sobol generator to generate the n'th number
	   we generate the n-1'th number for use in the recurrence
	   relation*/
        counter->in = counter->start - 1;
	i = counter->in;
	i >>= 1;
	im = counter->in;
	im ^= i;
 	for (k=1;k<=MAXDIM;k++) counter->ix[k] = 0; //0.0; float? -rjs
	for (j=1;j<=MAXBIT;j++) { 
	  /* work through digits of Gray code n (round no.) */
	  if (im & 1) { 
	    l = (j-1) * MAXDIM; /* direction nos. count from 0 */
	    for (k=1;k<=MAXDIM ;k++)
	      counter->ix[k] ^= sobol_iv[l+k];
	  }
	  im >>= 1;
	}

    } 

}

//=================================================================//
//		      original											   //
//=================================================================//
void sobseq(struct SobolData *counter, double *x)
{
    int j,k,l;
    unsigned long i,im;

    if(sobol_init == 0) {
      fprintf(stderr, "sobseq(): Must initialise sobseq first."
	     " Exiting...\n");
      exit(0);
    }
    if(counter->dimension<1 || counter->blocksize<1) {
      fprintf(stderr, "sobseq(): Must set dimension and blocksize first."
	     " Exiting...\n");
      exit(0);
    }

    /* loops through this counter->blocksize number of times, to
       give a block of Sobol numbers/vectors of dimension 
       counter->dimension */
    if (counter->dimension > 0) {
      l = counter->dimension < MAXDIM ? counter->dimension : MAXDIM;
      for(i=0; i<(counter->blocksize); i++) {
        im=counter->in;

	/*find right-most zero bit of n*/
        for (j=1;j<=MAXBIT;j++) { 
            if (!(im & 1)) break;
            im >>= 1;
        }

        if (j > MAXBIT) fprintf(stderr, "MAXBIT too small in sobseq\n");
        im=(j-1)*MAXDIM;

	/*Antonov-Saleev recurrence relation: */
        for (k=1;k<=l;k++) { 
            counter->ix[k] ^= sobol_iv[im+k];
            x[i*l + k]=counter->ix[k] * counter->fac;
        }
        counter->in++;
      }
    }
}


/*for the d'th primitive polynomial in ip, mdeg returns its order */

unsigned long mdeg(int d) 
{                         
  if((100< d) && (d < 161)) return 10UL;
  if((52 < d) && (d < 101)) return 9UL;
  if((36 < d) && (d < 53)) return 8UL;
  if((18 < d) && (d < 37)) return 7UL;
  if((12 < d) && (d < 19)) return 6UL;
  if((6 < d) && (d < 13)) return 5UL;
  if((d == 5) || (d == 6)) return 4UL;
  if((d == 3) || (d == 4)) return 3UL;
  if(d == 2) return 2UL;
  if(d == 1) return 1UL;

  fprintf(stderr, "Cannot find %d polynomial\n", d);
  exit(1);
}
//======================================================================//
//                                                                      //
//======================================================================//
/*changes all direction nos. by 2 each time, reversing when at 
endpoint(1 and 2^mdeg) */
/*(assumes mdeg <= 10)*/
/* Although this uses statics, it is used only in the global 
initialisation, which is called once*/

unsigned long initial(unsigned long deg, int dir_no) 
{                                       
  /*  static last_deg = 0; */
  static unsigned long last_deg = 0;
  static char sign[11] = 
                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
  static int i[11] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
        /*count from 1 */

  /*if(dir_no == 1) printf("\n\nmdeg = %ld\n", deg);*/
  if(dir_no == 1) return 1;

  if(deg == last_deg)  /*have we changed prim poly degree*/
  { 
    /*is it an endpoint*/
    if(i[dir_no]<1.1 || (pow(2.0, (double)dir_no)-1.1) < i[dir_no])
      sign[dir_no] *= -1;
    i[dir_no] += (int) sign[dir_no] * 2;
    return i[dir_no];

  } else {
      /*this ensures the first poly of mdeg has all iv=1 */
      if(dir_no == deg) last_deg = deg; 
      i[dir_no] = 1;
      sign[dir_no] = -1;
      return i[dir_no];
    }

}


//**************************************************************************//
//-------------------------------------------------------------//
//                                                             //
//   Scalar Inverse Normal Tranformation Function              //
//                                                             //
//-------------------------------------------------------------//
//
/***************************************************************************

Inverse cumulative normal funtion using Moro's algorithm.

Usage: invnorm(arg) returns the inverse of arg (all of type double).

This is faster than the standard Box-Muller algorithm. This also does
not reorder the sequence (by discarding points). Moro states the maximum
error is 3 * 10^-9 . This can be used in the range 10^-10 < arg < 1 - 10^-10.

****************************************************************************/

double invnorm(double z)
{
  int n;
  double y;
  double asum = 0.0;
  double bsum = 0.0;
  double result;
  const static double a[] = 
            {2.50662823844, -18.61500062529, 41.39119773534, -25.44106049637};
  const static double b[] = 
        {1.0, -8.47351093090, 23.08336743743, -21.06224101826, 3.13082909833};
  const static double c[] = 
               {7.7108870705487895, 2.7772013533685169, 0.3614964129261002,
		0.0373418233434554, 0.0028297143036967, 0.0001625716917922,
		0.0000080173304740, 0.0000003840919865, 0.0000000129707170};
  const static double k[] = { 0.4179886424926431, 4.2454686881376569 };
  double d[10];

  /* Check input is between 0 and 1. */
  if( (z<=0) || (z>=1) ) {
    fprintf(stderr, "invnorm: Error. Cannot calculate inverse cumulative"
	    " normal of x with x <= 0 or x >= 1\n"
	    "\tz = %f\n", z);
    exit(1);
  }

  y = z - 0.5;

  /* central region approximation */
  if( (0.08<=z) && (z<=0.92) ) {

    for(n=0;n<4;n++)
      asum += a[n] * pow(y, 2*n);

    for(n=0;n<5;n++)
      bsum += b[n] * pow(y, 2*n);

    result = y * asum / bsum;

  } else { 

    /* Tails approximation */

    y = k[0] * (2 * log( - log(0.5 - fabs(y)) ) - k[1]);


    d[9] = 0.0;
    d[8] = c[8];
    for(n=7;n>0;n--)
      d[n] = 2*y*d[n+1] - d[n+2] + c[n];

    result = y*d[1] - d[2] + 0.5 * c[0];

    if(z<0.08) result = - result;

  }

  return result;
}



/* Small wrapper to produce scalar RV's */
long uni_ldisc(SobolData *C, long lo, long hi) {
  double vec[2];
  sobseq(C, vec);
  return (lo + (long int) ((hi-lo+1)*vec[1]));
}
    
#undef IN_SOBOL_GENERATOR

